---
title: "Problem Set 5"
author: "Sydney Yeomans"
format:
  html:
    embed-resources: true
editor: visual
---

## Problem 1

Create a class to represent Wald-style normal approximation Confidence Intervals. Do this using S4

a.  For the waldCI class, define the following:

```{r}
#| echo: true
#1. a constructor
setClass("waldCI", slots = c(level = "numeric", mean = "numeric", sterr = "numeric",
                             lb = "numeric", ub = "numeric"))

#TAKES IN level
waldCI_constructor <- function(level, mean = NULL, sterr = NULL,
                               lb = NULL, ub = NULL) {
  #if given a mean ans std error need to calc lb & ub
  #CI = mean +- critical val * se
  cv <- qnorm(1 - (1 - level)/2)
  if (!is.null(mean) & !is.null(sterr)) {
    lb <- mean - cv * sterr
    ub <- mean + cv * sterr
  }
  #if given a lb ans ub need to find mean and se
  if (!is.null(lb) & !is.null(ub)) {
    mean <- (lb + ub) / 2
    sterr <- (ub - lb) / (2 * cv)
  }
  return(new("waldCI", level = level, mean = mean, sterr = sterr, 
             lb = lb, ub = ub))
}

#2. a validator
setValidity("waldCI", function(object){
  if (object@lb >= object@ub) {
    return(paste("@lb = ", object@lb, "is not smaller than ub"))
  }
  if (object@sterr < 0) {
    return(paste("@sterr = ", object@sterr, "is negative, make positive"))
  }
  if (object@level <= 0) {
    return(paste("@level = ", object@level, "is < or = 0, must be in (0,1)"))
  }
  if (object@level >= 1) {
    return(paste("@level = ", object@level, "is > or = 1, must be in (0,1)"))
  }
  if (!is.finite(object@lb)) {
    return(paste("@lb =", object@lb, "is not finite"))
  }
  if (!is.finite(object@ub)) {
    return(paste("@ub =", object@ub, "is not finite"))
  }
  return(TRUE)
})

#3. a show method
##' @title Display a `waldCI` object
##' @param object A `waldCI` object
setMethod("show", "waldCI",
  function(object) {
    cat("Mean-", object@mean, "\n")
    cat("SE-", object@sterr, "\n")
    cat("Lower bound-", object@lb, "\n")
    cat("Upper bound-", object@ub, "\n")
    cat("Confidence level-", object@level, "\n")
    cat("\n")
    return(invisible(object))
  }
)

```

```{r}
#| echo: true
#4. Accessors
#setGeneric and setMethods 
#mean
setGeneric("mean",
           function(object) {
             standardGeneric("mean")
           })
##' @title Return the mean of a `waldCI`
##' @param object A `waldCI` object
##' @return It's mean
setMethod("mean", "waldCI",
          function(object) {
            return(slot(object, "mean"))
          })

#se
setGeneric("sterr",
           function(object) {
             standardGeneric("sterr")
           })
##' @title Return the standard error of a `waldCI`
##' @param object A `waldCI` object
##' @return It's SE
setMethod("sterr", "waldCI",
          function(object) {
            return(slot(object, "sterr"))
          })

#lb
setGeneric("lb",
           function(object) {
             standardGeneric("lb")
           })
##' @title Return the lower bound of a `waldCI`
##' @param object A `waldCI` object
##' @return It's lower bound
setMethod("lb", "waldCI",
          function(object) {
            return(slot(object, "lb"))
          })

#upb
setGeneric("ub",
           function(object) {
             standardGeneric("ub")
           })
##' @title Return the upper bound of a `waldCI`
##' @param object A `waldCI` object
##' @return It's upper bound
setMethod("ub", "waldCI",
          function(object) {
            return(slot(object, "ub"))
          })

#level
setGeneric("level",
           function(object) {
             standardGeneric("level")
           })
##' @title Return the level of a `waldCI`
##' @param object A `waldCI` object
##' @return It's confidence level
setMethod("level", "waldCI",
          function(object) {
            return(slot(object, "level"))
          })


#5. setters 
#setGeneric and setMethods, same but with <-
#mean
setGeneric("mean<-",
           function(object, value) {
             standardGeneric("mean<-")
           })
##' @title Set the mean of a `waldCI`
##' @param object A `waldCI` object
##' @param value New mean
##' @return The updated object
setMethod("mean<-", "waldCI",
  function(object, value) {
    object@mean <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#se
setGeneric("sterr<-",
           function(object, value) {
             standardGeneric("sterr<-")
           })
##' @title Set the std error of a `waldCI`
##' @param object A `waldCI` object
##' @param value New std error
##' @return The updated object
setMethod("sterr<-", "waldCI",
  function(object, value) {
    object@sterr <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#lb
setGeneric("lb<-",
           function(object, value) {
             standardGeneric("lb<-")
           })
##' @title Set the lower_bound of a `waldCI`
##' @param object A `waldCI` object
##' @param value New lower_bound
##' @return The updated object
setMethod("lb<-", "waldCI",
  function(object, value) {
    object@lb <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#upb
setGeneric("ub<-",
           function(object, value) {
             standardGeneric("ub<-")
           })
##' @title Set the upper_bound of a `waldCI`
##' @param object A `waldCI` object
##' @param value New upper_bound
##' @return The updated object
setMethod("ub<-", "waldCI",
  function(object, value) {
    object@ub <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#level
setGeneric("level<-",
           function(object, value) {
             standardGeneric("level<-")
           })
##' @title Set the level of a `waldCI`
##' @param object A `waldCI` object
##' @param value New level
##' @return The updated object
setMethod("level<-", "waldCI",
  function(object, value) {
    object@level <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#6. a contain method
##' @title See if value is in `waldCI`
##' @param object A `waldCI` object
##' @param value a numeric value
##' @return a logical of whether a value is within a CI
setGeneric("contains",
           function(object, value) {
             standardGeneric("contains")
           })

setMethod("contains", "waldCI", function(object, value){
  lower <- object@lb
  upper <- object@ub
  if (value >= lower & value <= upper) {
    return(TRUE)
  }
  return(FALSE)
})

```

```{r}
#7. an overlap method
##' @title See if two `waldCI` overlap
##' @param object the first `waldCI` object
##' @param object the second `waldCI` object
##' @return a logical of whether the two CIs overlap.
setGeneric("overlap",
           function(object1, object2) {
             standardGeneric("overlap")
           })

#one # lies inside both intervals
#intervals overlap if the end of the first is bigger than the lower bound of the second
#or need the lower bound of the first to be between low2 and up2
setMethod("overlap", c("waldCI", "waldCI"), function(object1, object2){
  lower_1 <- object1@lb
  upper_1 <- object1@ub
  lower_2 <- object2@lb
  upper_2 <- object2@ub
  if (lower_1 <= upper_2 && upper_1 >= lower_2) {
    return(TRUE)
  }
  return(FALSE)
})

#8. as.numeric to return c(lb, ub)
##' @title get the bounds of a `waldCI` overlap
##' @param x object existing s3 function uses 
##' @return return c(lb, ub)
setMethod("as.numeric", "waldCI",function(x) {
  return(c(x@lb, x@ub))
})
```

```{r}
#9. transformCI:
#install.packages("numDeriv")
#library(numDeriv)
#had help from chat for making this extra function
check_mono <- function(f,lb,ub,n=100){
  xs <- seq(lb, ub, length.out = n)
  grads <- sapply(xs, function(x) grad(f, x)) 
  all(grads >= 0) || all(grads <= 0)
}
##' @title transform a `waldCI` object using a monotonci function
##' @param object A `waldCI` object
##' @param func monotone function 
##' @return the transformed `waldCI` object
##' @warn Warn the user that only monotonic functions make sense.
setGeneric("transformCI",
           function(object, func) {
             standardGeneric("transformCI")
           })
setMethod("transformCI", "waldCI", function(object, func){
  warning("Only monotonic functions make sense")
  if (!check_mono(func, object@lb, object@ub)) {
    stop("Function is not monotonic on the interval")
  }
  new_lb <- func(object@lb)
  new_ub <- func(object@ub)
  
  waldCI_constructor(level = object@level, lb = new_lb, ub = new_ub)
})

```
I knew I wanted to make a separate function to check the input function was monotone, but didn't really know how to do so without doing a derivative check so had Chat give me some packages that take derivatives of function and it gave me numDeriv. Did some reading on the package and thought it would work for these questions specifically. It then helped me after a poor attempt at checking the if monotone or not and this is how the extra function was made.  


b.  Use your waldCI class to create three objects:

```{r}
#| echo: true
#ci1: (17.2, 24.7), 95%
#ci2: mean: 13, standard error: 2.5, 99%
#ci3: (27.43, 39.22), 75%

ci1 <- waldCI_constructor(level = .95, lb = 17.2, ub = 24.7)
ci2 <- waldCI_constructor(level = .99, mean = 13, sterr = 2.5)
ci3 <- waldCI_constructor(level = .75, lb = 27.3, ub = 39.22)

```

```{r}
#evaluate
ci1
ci2
ci3
as.numeric(ci1)
as.numeric(ci2)
as.numeric(ci3)
lb(ci2)
ub(ci2)
mean(ci1)
sterr(ci3)
level(ci2)
lb(ci2) <- 10.5
mean(ci3) <- 34
level(ci3) <- .8
contains(ci1, 17)
contains(ci3, 44)
overlap(ci1, ci2)
eci1 <- transformCI(ci1, sqrt)
eci1
mean(transformCI(ci2, log))
```

c.  Show that your validator does not allow the creation of invalid confidence intervals:

```{r, error=TRUE}
#| echo: true
#negative standard error
ci4 <- waldCI_constructor(level = .95, mean = 10, sterr = -2)
```
This error still shows that it doesn't work with a negative standard error even without getting to that check since the calculation for the bounds is thrown off due to the negative and we get an error from that as well. 

```{r, error=TRUE}
#| echo: true
#lb > ub
ci5 <- waldCI_constructor(level = .95, lb = 23, ub = 17)
```

```{r, error=TRUE}
#| echo: true
#Infinite bounds
ci6 <- waldCI_constructor(level = .95, lb = -Inf, ub = Inf)
```

```{r, error=TRUE}
#| echo: true
#invalid use of the setters
ci7 <- waldCI_constructor(level = .95, mean = 15, sterr = 3)
level(ci7) <- 1
```

```{r, error=TRUE}
#| echo: true
sterr(ci7) <- -3
```

```{r, error=TRUE}
#| echo: true
ub(ci7) <- 10
lb(ci7) <- 12
```

I didn't know if we had to show that all the setters worked properly and the validator covered all cases so I just did all of them to be safe. 

## Problem 3

Repeat problem set 4, question 3, using plotly.

```{r}
#install.packages("plotly")
library(plotly)
library(ggplot2)
library(tidyverse)
library(dplyr)
```

```{r}
#| echo: true
nyt <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv")
```

a.  How many major and minor spikes in cases were there?

```{r}
#| echo: true
nyt$date <- as.Date(nyt$date)

nyt_spikes <- nyt %>%
              mutate(month = format(as.Date(date), "%Y-%m")) %>%  
              group_by(month) %>%
              summarize(monthly_cases = sum(cases, na.rm = TRUE)) %>%
              ungroup()

p <- plot_ly(nyt_spikes, x = ~ month, y = ~ monthly_cases, type = "scatter", 
        mode = "lines+markers")

p2 <- p %>% layout(title = "Monthly COVID Cases in the US",
                  xaxis = list(title="Month"),
                  yaxis = list(title="Total Cases"))
p2
```

From this we see the same thing we say in the last problem set, that there are 7 spikes (5 minor and 2 major). It is nice being able to hover over the dots and see how many cases there are thanks to plotly.

b.  For the states with the highest and lowest overall rates per population, what differences do you see in their trajectories over time?

```{r}
#| echo: true
high_low <- nyt %>% 
            group_by(state) %>%
            summarize(highest_rate = max(cases_avg_per_100k, na.rm = TRUE)) %>%
            filter(highest_rate == max(highest_rate) | highest_rate == min(highest_rate))%>%
            ungroup()

nyt_highlow <- nyt %>%
               filter(state == "American Samoa" | state == "Maine")

nyt_highlow$date <- as.Date(nyt_highlow$date)

q <- plot_ly(nyt_highlow, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

q2 <- q %>% layout(title = "Comparison of States with Highest and Lowest Overall COVID Cases",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
q2

```

c.  Identify, to the best of your ability without a formal test, the first five states to experience Covid in a substantial way.

```{r}
#| echo: true
nyt_first <- nyt %>%
             group_by(state) %>%
             mutate(date = as.Date(date),
                    year = format(date, "%Y"),
                    state = factor(state)) %>%
             filter(year == "2020")

first_four_mon <- nyt %>%
                  group_by(state) %>%
                  mutate(date = as.Date(date),
                         year = format(date, "%Y"),
                         state = factor(state)) %>%
                  filter(date >= as.Date("2020-03-01"),
                         date <= as.Date("2020-04-30"))

r <- plot_ly(first_four_mon, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

r2 <- r %>% layout(title = "First States to Experience COVID in a Substantial Way (2020)",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
r2

```

From this first plot, that focuses solely on the first four months of 2020, we see that New York, New Jersey, and Louisiana are way above the other states so we can guess that they are some of the first states to experience COVID in a substantial way. The other two are convoluted but we can just take the top 7-8 and then go from there. Zooming in on the plotly we already made we can see other states that have early peaks are Massachusetts, Connecticut, Michigan, and DC (which were the ones showing up last time with ggplot as well). So let us subset the data to just these states.

```{r}
#| echo: true
seven_states <- c("New York", "New Jersey", "Louisiana", "Massachusetts", 
                  "Connecticut", "District of Columbia", "Michigan")

top_sev <- nyt %>%
            filter(state %in% seven_states) %>%
            mutate(date = as.Date(date),
                   year = format(date, "%Y"),
                   state = factor(state, levels = seven_states)) %>%
            filter(date >= as.Date("2020-03-01"),
                   date <= as.Date("2020-04-30"))

s <- plot_ly(top_sev, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

s2 <- s %>% layout(title = "First Seven States to Experience COVID in a Substantial Way (2020)",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
s2

```

If we zoom in and try to see which of these seven reached 10 cases on average per 100k we can pick out the top 5. Of course NY, NJ, and LA, show up again and if we focus on this threshold the other two are MA and CT. Now I will make a last graph just focusing on these 5: NY, NJ, MA, LA, and CT.

```{r}
#| echo: true
funf_state <- c("New York", "New Jersey", "Louisiana", "Massachusetts", 
                  "Connecticut")

top_five <- nyt %>%
            filter(state %in% funf_state) %>%
            mutate(date = as.Date(date),
                   year = format(date, "%Y"),
                   state = factor(state, levels = funf_state)) %>%
            filter(year == "2020")

t <- plot_ly(top_five, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

t2 <- t %>% layout(title = "First 5 States to Experience COVID in a Substantial Way (2020)",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
t2

```

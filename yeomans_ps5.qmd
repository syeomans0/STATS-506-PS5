---
title: "Problem Set 5"
author: "Sydney Yeomans"
format:
  html:
    embed-resources: true
editor: visual
---

## Problem 1
Create a class to represent Wald-style normal approximation Confidence Intervals. Do this using S4

a. For the waldCI class, define the following:

```{r}
#1. a constructor
wald_approx_CI <- setClass("waldCI", slots = c(mean = "numeric", sterr = "numeric",
                             lb = "numeric", ub = "numeric", level = "numeric"))

waldCI_constructor <- function(x, color) {
  return(new("color_vector", data = x, color = color))
}

#2. a validator
setValidity("color_vector", function(object){
  if (!(object@color %in% colors())) {
    stop(paste("@color = ", object@color, "is not a valid color"))
  }
  return(TRUE)
})

#3. a show method
##' @title Display a `waldCI` object
##' @param object A `waldCI` object
setMethod("show", "waldCI",
  function(object) {
    cat("Mean-", object@mean)
    cat("SE-", object@sterr)
    cat("Lower bound-", object@lb)
    cat("Upper bound-", object@ub)
    cat("Confidence level-", object@level)
    cat("\n")
    return(invisible(object))
  }
)

```


```{r}
#4. Accessors
#setGeneric and setMethods 
#mean
setGeneric("mean",
           function(object) {
             standardGeneric("mean")
           })
##' @title Return the mean of a `waldCI`
##' @param object A `waldCI` object
##' @return It's mean
setMethod("mean", "waldCI",
          function(object) {
            return(slot(object, "mean"))
          })

#se
setGeneric("sterr",
           function(object) {
             standardGeneric("sterr")
           })
##' @title Return the standard error of a `waldCI`
##' @param object A `waldCI` object
##' @return It's SE
setMethod("sterr", "waldCI",
          function(object) {
            return(slot(object, "sterr"))
          })

#lb
setGeneric("lb",
           function(object) {
             standardGeneric("lb")
           })
##' @title Return the lower bound of a `waldCI`
##' @param object A `waldCI` object
##' @return It's lower bound
setMethod("lb", "waldCI",
          function(object) {
            return(slot(object, "lb"))
          })

#upb
setGeneric("ub",
           function(object) {
             standardGeneric("ub")
           })
##' @title Return the upper bound of a `waldCI`
##' @param object A `waldCI` object
##' @return It's upper bound
setMethod("ub", "waldCI",
          function(object) {
            return(slot(object, "ub"))
          })

#level
setGeneric("level",
           function(object) {
             standardGeneric("level")
           })
##' @title Return the level of a `waldCI`
##' @param object A `waldCI` object
##' @return It's confidence level
setMethod("level", "waldCI",
          function(object) {
            return(slot(object, "level"))
          })


#5. setters 
#setGeneric and setMethods, same but with <-
#mean
setGeneric("mean<-",
           function(object, value) {
             standardGeneric("mean<-")
           })
##' @title Set the mean of a `waldCI`
##' @param object A `waldCI` object
##' @param value New mean
##' @return The updated object
setMethod("mean<-", "waldCI",
  function(object, value) {
    object@mean <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#se
setGeneric("sterr<-",
           function(object, value) {
             standardGeneric("sterr<-")
           })
##' @title Set the std error of a `waldCI`
##' @param object A `waldCI` object
##' @param value New std error
##' @return The updated object
setMethod("sterr<-", "waldCI",
  function(object, value) {
    object@sterr <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#lb
setGeneric("lb<-",
           function(object, value) {
             standardGeneric("lb<-")
           })
##' @title Set the lower_bound of a `waldCI`
##' @param object A `waldCI` object
##' @param value New lower_bound
##' @return The updated object
setMethod("lb<-", "waldCI",
  function(object, value) {
    object@lb <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#upb
setGeneric("ub<-",
           function(object, value) {
             standardGeneric("ub<-")
           })
##' @title Set the upper_bound of a `waldCI`
##' @param object A `waldCI` object
##' @param value New upper_bound
##' @return The updated object
setMethod("ub<-", "waldCI",
  function(object, value) {
    object@ub <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#level
setGeneric("level<-",
           function(object, value) {
             standardGeneric("level<-")
           })
##' @title Set the level of a `waldCI`
##' @param object A `waldCI` object
##' @param value New level
##' @return The updated object
setMethod("level<-", "waldCI",
  function(object, value) {
    object@level <- value
    validObject(object) # Re-run validity check
    return(object)
  }
)

#6. a contain method
##' @title See if value is in `waldCI`
##' @param object A `waldCI` object
##' @param value a numeric value
##' @return a logical of whether a value is within a CI
setGeneric("contains",
           function(object, value) {
             standardGeneric("contains")
           })

setMethod("contains", "waldCI", function(object, value){
  lower <- object@lb
  upper <- object@ub
  if (value >= lower & value <= upper) {
    return(TRUE)
  }
  return(FALSE)
})

```


```{r}
#7. an overlap method
##' @title See if two `waldCI` overlap
##' @param object the first `waldCI` object
##' @param object the second `waldCI` object
##' @return a logical of whether the two CIs overlap.
setGeneric("overlap",
           function(object1, object2) {
             standardGeneric("overlap")
           })

#one # lies inside both intervals
#intervals overlap if the end of the first is bigger than the lower bound of the second
#or need the lower bound of the first to be between low2 and up2
setMethod("overlap", c("waldCI", "waldCI"), function(object1, object2){
  lower_1 <- object1@lb
  upper_1 <- object1@ub
  lower_2 <- object2@lb
  upper_2 <- object2@ub
  if (lower_1 <= upper_2 && upper_1 >= lower_2) {
    return(TRUE)
  }
  return(FALSE)
})

#8. as.numeric to return c(lb, ub)
##' @title See if two `waldCI` overlap
##' @param object the first `waldCI` object
##' @param object the second `waldCI` object
##' @return a logical of whether the two CIs overlap.
setMethod("as.numeric", "waldCI",function(object) {
  return(c(object@lb, object@ub))
})

#9. transformCI
##' @title transform a `waldCI` object using a monotonci function
##' @param object A `waldCI` object
##' @param func function 
##' @return the transformed `waldCI` object
##' @warn Warn the user that only monotonic functions make sense.
setGeneric("transformCI",
           function(object, func) {
             standardGeneric("transformCI")
           })
setMethod("transformCI", "waldCI", function(object, func){
  warning("Only monotonic functions make sense")
  
})

```



b. Use your waldCI class to create three objects:

```{r}
#ci1: (17.2, 24.7), 95%
#ci2: mean: 13, standard error: 2.5, 99%
#ci3: (27.43, 39.22), 75%

ci1 <- wald_approx_CI(lower_bound = 17.2, upper_bound = 24.7, level = .95)
ci2 <- wald_approx_CI(mean = 13, std_error = 2.5, level = .99)
ci3 <- wald_approx_CI(lower_bound = 27.3, upper_bound = 39.22, level = .75)

```

```{r}
#evaluate
ci1
ci2
ci3
as.numeric(ci1)
as.numeric(ci2)
as.numeric(ci3)
lb(ci2)
ub(ci2)
mean(ci1)
sterr(ci3)
level(ci2)
lb(ci2) <- 10.5
mean(ci3) <- 34
level(ci3) <- .8
contains(ci1, 17)
contains(ci3, 44)
overlap(ci1, ci2)
eci1 <- transformCI(ci1, sqrt)
eci1
mean(transformCI(ci2, log))
```

c. Show that your validator does not allow the creation of invalid confidence intervals: 

```{r}

```



## Problem 3
Repeat problem set 4, question 3, using plotly.

```{r}
install.packages("plotly")
library(plotly)
library(ggplot2)
library(tidyverse)
library(dplyr)
```

```{r}
#| echo: true
nyt <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv")
```

a. How many major and minor spikes in cases were there?

```{r}
#| echo: true
nyt$date <- as.Date(nyt$date)

nyt_spikes <- nyt %>%
              mutate(month = format(as.Date(date), "%Y-%m")) %>%  
              group_by(month) %>%
              summarize(monthly_cases = sum(cases, na.rm = TRUE)) %>%
              ungroup()

p <- plot_ly(nyt_spikes, x = ~ month, y = ~ monthly_cases, type = "scatter", 
        mode = "lines+markers")

p2 <- p %>% layout(title = "Monthly COVID Cases in the US",
                  xaxis = list(title="Month"),
                  yaxis = list(title="Total Cases"))
p2
```

From this we see the same thing we say in the last problem set, that there are 7 spikes (5 minor and 2 major). It is nice being able to hover over the dots and see how many cases there are thanks to plotly. 

b. For the states with the highest and lowest overall rates per population, what differences do you see in their trajectories over time?

```{r}
#| echo: true
high_low <- nyt %>% 
            group_by(state) %>%
            summarize(highest_rate = max(cases_avg_per_100k, na.rm = TRUE)) %>%
            filter(highest_rate == max(highest_rate) | highest_rate == min(highest_rate))%>%
            ungroup()

nyt_highlow <- nyt %>%
               filter(state == "American Samoa" | state == "Maine")

nyt_highlow$date <- as.Date(nyt_highlow$date)

q <- plot_ly(nyt_highlow, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

q2 <- q %>% layout(title = "Comparison of States with Highest and Lowest Overall COVID Cases",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
q2

```

c. Identify, to the best of your ability without a formal test, the first five states to experience Covid in a substantial way.

```{r}
#| echo: true
nyt_first <- nyt %>%
             group_by(state) %>%
             mutate(date = as.Date(date),
                    year = format(date, "%Y"),
                    state = factor(state)) %>%
             filter(year == "2020")

first_four_mon <- nyt %>%
                  group_by(state) %>%
                  mutate(date = as.Date(date),
                         year = format(date, "%Y"),
                         state = factor(state)) %>%
                  filter(date >= as.Date("2020-03-01"),
                         date <= as.Date("2020-04-30"))

r <- plot_ly(first_four_mon, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

r2 <- r %>% layout(title = "First States to Experience COVID in a Substantial Way (2020)",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
r2

```

From this first plot, that focuses solely on the first four months of 2020, we see that New York, New Jersey, and Louisiana are way above the other states so we can guess that they are some of the first states to experience COVID in a substantial way. The other two are convoluted but we can just take the top 7-8 and then go from there. Zooming in on the plotly we already made we can see other states that have early peaks are Massachusetts, Connecticut, Michigan, and DC (which were the ones showing up last time with ggplot as well). So let us subset the data to just these states.

```{r}
#| echo: true
seven_states <- c("New York", "New Jersey", "Louisiana", "Massachusetts", 
                  "Connecticut", "District of Columbia", "Michigan")

top_sev <- nyt %>%
            filter(state %in% seven_states) %>%
            mutate(date = as.Date(date),
                   year = format(date, "%Y"),
                   state = factor(state, levels = seven_states)) %>%
            filter(date >= as.Date("2020-03-01"),
                   date <= as.Date("2020-04-30"))

s <- plot_ly(top_sev, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

s2 <- s %>% layout(title = "First Seven States to Experience COVID in a Substantial Way (2020)",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
s2

```

If we zoom in and try to see which of these seven reached 10 cases on average per 100k we can pick out the top 5. Of course NY, NJ, and LA, show up again and if we focus on this threshold the other two are MA and CT. Now I will make a last graph just focusing on these 5: NY, NJ, MA, LA, and CT.

```{r}
#| echo: true
funf_state <- c("New York", "New Jersey", "Louisiana", "Massachusetts", 
                  "Connecticut")

top_five <- nyt %>%
            filter(state %in% funf_state) %>%
            mutate(date = as.Date(date),
                   year = format(date, "%Y"),
                   state = factor(state, levels = funf_state)) %>%
            filter(year == "2020")

t <- plot_ly(top_five, x = ~ date, y = ~ cases_avg_per_100k, color = ~ state, 
             type = "scatter", mode = "lines")

t2 <- t %>% layout(title = "First 5 States to Experience COVID in a Substantial Way (2020)",
                  xaxis = list(title="Date"),
                  yaxis = list(title="Cases on Average per 100K"))
t2

```


